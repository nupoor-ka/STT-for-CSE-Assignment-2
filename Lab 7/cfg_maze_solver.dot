digraph CFG {
  0 [label="Entry", shape=box];
  1 [label="int main()
const int MAXR = 40, MAXC = 40;
int rows = 24, cols = 24;
char maze[MAXR][MAXC];
int visited[MAXR][MAXC];
int parentR[MAXR][MAXC], parentC[MAXR][MAXC];
int i, j, k;
int startR = 1, startC = 1;
int endR = 22, endC = 22;
int choice, sub;
int trace = 0;
int seedChoice;
srand((unsigned)time(NULL));", shape=box];
  2 [label="for(i = 0; i &lt; rows; i++)", shape=box];
  3 [label="for(j = 0; j &lt; cols; j++)", shape=box];
  4 [label="if(i == 0 || j == 0 || i == rows - 1 || j == cols - 1)", shape=box];
  5 [label="maze[i][j] = &#x27;#&#x27;;", shape=box];
  6 [label="else", shape=box];
  7 [label="maze[i][j] = ((rand() % 100) &lt; 30) ? &#x27;#&#x27; : &#x27;.&#x27;;
visited[i][j] = 0;
parentR[i][j] = -1;
parentC[i][j] = -1;
maze[startR][startC] = &#x27;S&#x27;;
maze[endR][endC] = &#x27;E&#x27;;", shape=box];
  8 [label="while(1)", shape=box];
  9 [label="printf(&#x27;\\nMaze %d x %d  S=(%d,%d) E=(%d,%d)  trace=%s\\n&#x27;, rows, cols, startR, startC, endR, endC, trace ? &#x27;ON&#x27;:&#x27;OFF&#x27;);
printf(&#x27;1 Print  2 Trace toggle  3 Regenerate  4 Edit  5 DFS  6 BFS  7 A*  8 Stats  9 Resize  0 Exit\\n&#x27;);
printf(&#x27;Choose: &#x27;);", shape=box];
  10 [label="if(scanf(&#x27;%d&#x27;, &amp;choice) != 1)", shape=box];
  11 [label="int ch;", shape=box];
  12 [label="while((ch=getchar())!=EOF &amp;&amp; ch!=&#x27;\\n&#x27;)", shape=box];
  13 [label=";
printf(&#x27;Bad input\\n&#x27;);
continue;", shape=box];
  14 [label="if(choice == 0)", shape=box];
  15 [label="printf(&#x27;Exit\\n&#x27;);", shape=box];
  16 [label="break;", shape=box];
  17 [label="if(choice == 1)", shape=box];
  18 [label="printf(&#x27;   &#x27;);", shape=box];
  19 [label="for(j = 0; j &lt; cols; j++)", shape=box];
  20 [label="printf(&#x27;%c&#x27;, &#x27;0&#x27; + (j % 10));
printf(&#x27;\\n&#x27;);", shape=box];
  21 [label="for(i = 0; i &lt; rows; i++)", shape=box];
  22 [label="printf(&#x27;%2d &#x27;, i);", shape=box];
  23 [label="for(j = 0; j &lt; cols; j++)", shape=box];
  24 [label="printf(&#x27;%c&#x27;, maze[i][j]);
printf(&#x27;\\n&#x27;);
continue;", shape=box];
  25 [label="if(choice == 2)", shape=box];
  26 [label="trace = !trace;
printf(&#x27;Trace %s\\n&#x27;, trace ? &#x27;ON&#x27;:&#x27;OFF&#x27;);
continue;", shape=box];
  27 [label="if(choice == 3)", shape=box];
  28 [label="printf(&#x27;Seed: 1=random 2=enter int: &#x27;);", shape=box];
  29 [label="if(scanf(&#x27;%d&#x27;, &amp;seedChoice) != 1)", shape=box];
  30 [label="seedChoice = 1;", shape=box];
  31 [label="if(seedChoice == 2)", shape=box];
  32 [label="int s;
scanf(&#x27;%d&#x27;, &amp;s);
srand((unsigned)s);", shape=box];
  33 [label="else", shape=box];
  34 [label="srand((unsigned)time(NULL) ^ rand());", shape=box];
  35 [label="for(i = 0; i &lt; rows; i++)", shape=box];
  36 [label="for (j = 0;
j &lt; cols;
j++)", shape=box];
  37 [label="if(i==0||j==0||i==rows-1||j==cols-1)", shape=box];
  38 [label="maze[i][j]=&#x27;#&#x27;;", shape=box];
  39 [label="else", shape=box];
  40 [label="maze[i][j] = ((rand()%100) &lt; 35) ? &#x27;#&#x27; : &#x27;.&#x27;;
visited[i][j]=0;
parentR[i][j]=-1;
parentC[i][j]=-1;
maze[startR][startC]=&#x27;S&#x27;;
maze[endR][endC]=&#x27;E&#x27;;
printf(&#x27;Regenerated\\n&#x27;);
continue;", shape=box];
  41 [label="if(choice == 4)", shape=box];
  42 [label="printf(&#x27;Edit menu: 1 toggle cell  2 move S  3 move E  4 clear interior  0 back\\n&#x27;);", shape=box];
  43 [label="if(scanf(&#x27;%d&#x27;,&amp;sub)!=1)", shape=box];
  44 [label="sub = 0;", shape=box];
  45 [label="if(sub == 0)", shape=box];
  46 [label="continue;", shape=box];
  47 [label="if(sub == 1)", shape=box];
  48 [label="int r,c;
printf(&#x27;r c: &#x27;);", shape=box];
  49 [label="if(scanf(&#x27;%d %d&#x27;,&amp;r,&amp;c)!=2)", shape=box];
  50 [label="printf(&#x27;Bad\\n&#x27;);
continue;", shape=box];
  51 [label="if(r&lt;=0||c&lt;=0||r&gt;=rows-1||c&gt;=cols-1)", shape=box];
  52 [label="printf(&#x27;Invalid\\n&#x27;);
continue;", shape=box];
  53 [label="if((r==startR&amp;&amp;c==startC)||(r==endR&amp;&amp;c==endC))", shape=box];
  54 [label="printf(&#x27;Can&#x27;t toggle S/E\\n&#x27;);
continue;
maze[r][c] = (maze[r][c]==&#x27;#&#x27;) ? &#x27;.&#x27; : &#x27;#&#x27;;
printf(&#x27;Toggled (%d,%d) -&gt; %c\\n&#x27;, r, c, maze[r][c]);", shape=box];
  55 [label="else if(sub==2)", shape=box];
  56 [label="int nr,nc;
printf(&#x27;new S r c: &#x27;);", shape=box];
  57 [label="if(scanf(&#x27;%d %d&#x27;,&amp;nr,&amp;nc)!=2)", shape=box];
  58 [label="printf(&#x27;Bad\\n&#x27;);
continue;", shape=box];
  59 [label="if(nr&lt;=0||nc&lt;=0||nr&gt;=rows-1||nc&gt;=cols-1)", shape=box];
  60 [label="printf(&#x27;Invalid\\n&#x27;);
continue;
maze[startR][startC] = &#x27;.&#x27;;
startR=nr;
startC=nc;
maze[startR][startC]=&#x27;S&#x27;;
printf(&#x27;Moved S\\n&#x27;);", shape=box];
  61 [label="else if(sub==3)", shape=box];
  62 [label="int nr,nc;
printf(&#x27;new E r c: &#x27;);", shape=box];
  63 [label="if(scanf(&#x27;%d %d&#x27;,&amp;nr,&amp;nc)!=2)", shape=box];
  64 [label="printf(&#x27;Bad\\n&#x27;);
continue;", shape=box];
  65 [label="if(nr&lt;=0||nc&lt;=0||nr&gt;=rows-1||nc&gt;=cols-1)", shape=box];
  66 [label="printf(&#x27;Invalid\\n&#x27;);
continue;
maze[endR][endC]=&#x27;.&#x27;;
endR=nr;
endC=nc;
maze[endR][endC]=&#x27;E&#x27;;
printf(&#x27;Moved E\\n&#x27;);", shape=box];
  67 [label="else if(sub==4)", shape=box];
  68 [label="for(i=1;i&lt;rows-1;i++)", shape=box];
  69 [label="for (j=1;
j&lt;cols-1;
j++) maze[i][j]=&#x27;.&#x27;;
maze[startR][startC]=&#x27;S&#x27;;
maze[endR][endC]=&#x27;E&#x27;;
printf(&#x27;Cleared\\n&#x27;);", shape=box];
  70 [label="else", shape=box];
  71 [label="printf(&#x27;Unknown\\n&#x27;);
continue;", shape=box];
  72 [label="if(choice == 5)", shape=box];
  73 [label="int stackR[10000], stackC[10000], top = -1;", shape=box];
  74 [label="for(i=0;i&lt;rows;i++)", shape=box];
  75 [label="for (j=0;
j&lt;cols;
j++)
visited[i][j]=0;
parentR[i][j]=-1;
parentC[i][j]=-1;
int sr=startR, sc=startC;
visited[sr][sc]=1;
stackR[++top]=sr;
stackC[top]=sc;
int found=0, nodes=0;", shape=box];
  76 [label="while(top&gt;=0)", shape=box];
  77 [label="int cr = stackR[top];
int cc = stackC[top];
top--;
nodes++;", shape=box];
  78 [label="if(trace)", shape=box];
  79 [label="printf(&#x27;DFS pop (%d,%d)\\n&#x27;, cr, cc);", shape=box];
  80 [label="if(cr==endR &amp;&amp; cc==endC)", shape=box];
  81 [label="found=1;", shape=box];
  82 [label="break;
int dr[4] =
1,-1,0,0
;
int dc[4] =
0,0,1,-1
;", shape=box];
  83 [label="for(k=0;k&lt;4;k++)", shape=box];
  84 [label="int nr = cr + dr[k], nc = cc + dc[k];", shape=box];
  85 [label="if(nr&lt;=0||nc&lt;=0||nr&gt;=rows-1||nc&gt;=cols-1)", shape=box];
  86 [label="continue;", shape=box];
  87 [label="if(maze[nr][nc]==&#x27;#&#x27;)", shape=box];
  88 [label="continue;", shape=box];
  89 [label="if(visited[nr][nc])", shape=box];
  90 [label="continue;
visited[nr][nc]=1;
parentR[nr][nc]=cr;
parentC[nr][nc]=cc;
stackR[++top]=nr;
stackC[top]=nc;", shape=box];
  91 [label="if(trace)", shape=box];
  92 [label="printf(&#x27; DFS push (%d,%d)\\n&#x27;, nr, nc);", shape=box];
  93 [label="if(found)", shape=box];
  94 [label="int pr=endR, pc=endC, path=0;", shape=box];
  95 [label="while(!(pr==startR &amp;&amp; pc==startC) &amp;&amp; pr!=-1 &amp;&amp; pc!=-1)", shape=box];
  96 [label="if(maze[pr][pc]==&#x27;.&#x27;)", shape=box];
  97 [label="maze[pr][pc]=&#x27;*&#x27;;
int tr = parentR[pr][pc], tc = parentC[pr][pc];
pr=tr;
pc=tc;
path++;
maze[startR][startC]=&#x27;S&#x27;;
maze[endR][endC]=&#x27;E&#x27;;
printf(&#x27;DFS found path nodes=%d pathlen=%d\\n&#x27;, nodes, path);", shape=box];
  98 [label="else", shape=box];
  99 [label="printf(&#x27;DFS no path nodes=%d\\n&#x27;, nodes);
continue;", shape=box];
  100 [label="if(choice == 6)", shape=box];
  101 [label="int qR[10000], qC[10000], head=0, tail=0;", shape=box];
  102 [label="for(i=0;i&lt;rows;i++)", shape=box];
  103 [label="for (j=0;
j&lt;cols;
j++)
visited[i][j]=0;
parentR[i][j]=-1;
parentC[i][j]=-1;
qR[tail]=startR;
qC[tail]=startC;
tail++;
visited[startR][startC]=1;
int found=0, nodes=0;", shape=box];
  104 [label="while(head&lt;tail)", shape=box];
  105 [label="int cr=qR[head], cc=qC[head];
head++;
nodes++;", shape=box];
  106 [label="if(trace)", shape=box];
  107 [label="printf(&#x27;BFS pop (%d,%d)\\n&#x27;, cr, cc);", shape=box];
  108 [label="if(cr==endR &amp;&amp; cc==endC)", shape=box];
  109 [label="found=1;", shape=box];
  110 [label="break;
int dr[4]=
0,0,1,-1
, dc[4]=
1,-1,0,0
;", shape=box];
  111 [label="for(k=0;k&lt;4;k++)", shape=box];
  112 [label="int nr=cr+dr[k], nc=cc+dc[k];", shape=box];
  113 [label="if(nr&lt;=0||nc&lt;=0||nr&gt;=rows-1||nc&gt;=cols-1)", shape=box];
  114 [label="continue;", shape=box];
  115 [label="if(maze[nr][nc]==&#x27;#&#x27;)", shape=box];
  116 [label="continue;", shape=box];
  117 [label="if(visited[nr][nc])", shape=box];
  118 [label="continue;
visited[nr][nc]=1;
parentR[nr][nc]=cr;
parentC[nr][nc]=cc;
qR[tail]=nr;
qC[tail]=nc;
tail++;", shape=box];
  119 [label="if(trace)", shape=box];
  120 [label="printf(&#x27; BFS push (%d,%d)\\n&#x27;, nr, nc);", shape=box];
  121 [label="if(found)", shape=box];
  122 [label="int pr=endR, pc=endC, path=0;", shape=box];
  123 [label="while(!(pr==startR &amp;&amp; pc==startC) &amp;&amp; pr!=-1 &amp;&amp; pc!=-1)", shape=box];
  124 [label="if(maze[pr][pc]==&#x27;.&#x27;)", shape=box];
  125 [label="maze[pr][pc]=&#x27;+&#x27;;
int tr=parentR[pr][pc], tc=parentC[pr][pc];
pr=tr;
pc=tc;
path++;
maze[startR][startC]=&#x27;S&#x27;;
maze[endR][endC]=&#x27;E&#x27;;
printf(&#x27;BFS found path nodes=%d pathlen=%d\\n&#x27;, nodes, path);", shape=box];
  126 [label="else", shape=box];
  127 [label="printf(&#x27;BFS no path nodes=%d\\n&#x27;, nodes);
continue;", shape=box];
  128 [label="if(choice == 7)", shape=box];
  129 [label="for(i=0;i&lt;rows;i++)", shape=box];
  130 [label="for (j=0;
j&lt;cols;
j++)
visited[i][j]=0;
parentR[i][j]=-1;
parentC[i][j]=-1;
int openR[10000], openC[10000], openG[10000], openF[10000];
int openN=0;
openR[openN]=startR;
openC[openN]=startC;
openG[openN]=0;
openF[openN]=abs(startR-endR)+abs(startC-endC);
openN++;
int closed[MAXR][MAXC];", shape=box];
  131 [label="for(i=0;i&lt;rows;i++)", shape=box];
  132 [label="for (j=0;
j&lt;cols;
j++) closed[i][j]=0;
int found=0, nodes=0;", shape=box];
  133 [label="while(openN&gt;0)", shape=box];
  134 [label="int best=0;", shape=box];
  135 [label="for(i=1;i&lt;openN;i++)", shape=box];
  136 [label="if (openF[i]&lt;openF[best]) best=i;
int cr=openR[best], cc=openC[best], cg=openG[best];
openN--;
openR[best]=openR[openN];
openC[best]=openC[openN];
openG[best]=openG[openN];
openF[best]=openF[openN];", shape=box];
  137 [label="if(trace)", shape=box];
  138 [label="printf(&#x27;A* expand (%d,%d) g=%d\\n&#x27;, cr, cc, cg);", shape=box];
  139 [label="if(cr==endR &amp;&amp; cc==endC)", shape=box];
  140 [label="found=1;", shape=box];
  141 [label="break;
closed[cr][cc]=1;
nodes++;
int dr[4]=
1,-1,0,0
, dc[4]=
0,0,1,-1
;", shape=box];
  142 [label="for(k=0;k&lt;4;k++)", shape=box];
  143 [label="int nr=cr+dr[k], nc=cc+dc[k];", shape=box];
  144 [label="if(nr&lt;=0||nc&lt;=0||nr&gt;=rows-1||nc&gt;=cols-1)", shape=box];
  145 [label="continue;", shape=box];
  146 [label="if(maze[nr][nc]==&#x27;#&#x27;)", shape=box];
  147 [label="continue;", shape=box];
  148 [label="if(closed[nr][nc])", shape=box];
  149 [label="continue;
int ng = cg+1;
int h = abs(nr-endR)+abs(nc-endC);
int nf = ng + h;
int inOpen=-1;", shape=box];
  150 [label="for(i=0;i&lt;openN;i++)", shape=box];
  151 [label="if (openR[i]==nr &amp;&amp; openC[i]==nc)
inOpen=i;", shape=box];
  152 [label="break;", shape=box];
  153 [label="if(inOpen&gt;=0)", shape=box];
  154 [label="if(ng &lt; openG[inOpen])", shape=box];
  155 [label="openG[inOpen]=ng;
openF[inOpen]=nf;
parentR[nr][nc]=cr;
parentC[nr][nc]=cc;", shape=box];
  156 [label="else", shape=box];
  157 [label="openR[openN]=nr;
openC[openN]=nc;
openG[openN]=ng;
openF[openN]=nf;
parentR[nr][nc]=cr;
parentC[nr][nc]=cc;
openN++;", shape=box];
  158 [label="if(trace)", shape=box];
  159 [label="printf(&#x27; A* add (%d,%d) g=%d f=%d\\n&#x27;, nr, nc, ng, nf);", shape=box];
  160 [label="if(found)", shape=box];
  161 [label="int pr=endR, pc=endC, path=0;", shape=box];
  162 [label="while(!(pr==startR &amp;&amp; pc==startC) &amp;&amp; pr!=-1 &amp;&amp; pc!=-1)", shape=box];
  163 [label="if(maze[pr][pc]==&#x27;.&#x27;)", shape=box];
  164 [label="maze[pr][pc]=&#x27;A&#x27;;
int tr=parentR[pr][pc], tc=parentC[pr][pc];
pr=tr;
pc=tc;
path++;
maze[startR][startC]=&#x27;S&#x27;;
maze[endR][endC]=&#x27;E&#x27;;
printf(&#x27;A* found path nodes=%d pathlen=%d\\n&#x27;, nodes, path);", shape=box];
  165 [label="else", shape=box];
  166 [label="printf(&#x27;A* no path nodes=%d\\n&#x27;, nodes);
continue;", shape=box];
  167 [label="if(choice == 8)", shape=box];
  168 [label="int walls=0, empt=0;", shape=box];
  169 [label="for(i=0;i&lt;rows;i++)", shape=box];
  170 [label="for (j=0;
j&lt;cols;
j++)", shape=box];
  171 [label="if(maze[i][j]==&#x27;#&#x27;)", shape=box];
  172 [label="walls++;", shape=box];
  173 [label="else", shape=box];
  174 [label="empt++;
printf(&#x27;Cells %d walls %d empty %d density %.3f\\n&#x27;, rows*cols, walls, empt, (double)walls/(rows*cols));", shape=box];
  175 [label="for(i=0;i&lt;rows;i++)", shape=box];
  176 [label="for (j=0;
j&lt;cols;
j++) visited[i][j]=0;
int qR[10000], qC[10000], h=0, t=0;
qR[t]=startR;
qC[t]=startC;
t++;
visited[startR][startC]=1;
int reach=0;", shape=box];
  177 [label="while(h&lt;t)", shape=box];
  178 [label="int cr=qR[h], cc=qC[h];
h++;
reach++;
int dr[4]=
1,-1,0,0
, dc[4]=
0,0,1,-1
;", shape=box];
  179 [label="for(k=0;k&lt;4;k++)", shape=box];
  180 [label="int nr=cr+dr[k], nc=cc+dc[k];", shape=box];
  181 [label="if(nr&lt;=0||nc&lt;=0||nr&gt;=rows-1||nc&gt;=cols-1)", shape=box];
  182 [label="continue;", shape=box];
  183 [label="if(maze[nr][nc]==&#x27;#&#x27;)", shape=box];
  184 [label="continue;", shape=box];
  185 [label="if(visited[nr][nc])", shape=box];
  186 [label="continue;
visited[nr][nc]=1;
qR[t]=nr;
qC[t]=nc;
t++;
printf(&#x27;Reachable from S: %d\\n&#x27;, reach);", shape=box];
  187 [label="for(i=0;i&lt;rows;i++)", shape=box];
  188 [label="for (j=0;
j&lt;cols;
j++) visited[i][j]=0;
int stkR[10000], stkC[10000], it[10000], sp=-1, maxD=0, depth=0;
sp++;
stkR[sp]=startR;
stkC[sp]=startC;
it[sp]=0;
visited[startR][startC]=1;
depth=1;", shape=box];
  189 [label="while(sp&gt;=0)", shape=box];
  190 [label="int cr=stkR[sp], cc=stkC[sp], itv=it[sp];", shape=box];
  191 [label="if(itv&gt;3)", shape=box];
  192 [label="sp--;
depth--;
continue;
it[sp] = itv+1;
int dr[4]=
1,-1,0,0
, dc[4]=
0,0,1,-1
;
int nr=cr+dr[itv], nc=cc+dc[itv];", shape=box];
  193 [label="if(nr&lt;=0||nc&lt;=0||nr&gt;=rows-1||nc&gt;=cols-1)", shape=box];
  194 [label="continue;", shape=box];
  195 [label="if(maze[nr][nc]==&#x27;#&#x27;)", shape=box];
  196 [label="continue;", shape=box];
  197 [label="if(visited[nr][nc])", shape=box];
  198 [label="continue;
visited[nr][nc]=1;
sp++;
stkR[sp]=nr;
stkC[sp]=nc;
it[sp]=0;
depth++;", shape=box];
  199 [label="if(depth&gt;maxD)", shape=box];
  200 [label="maxD=depth;
printf(&#x27;Heuristic max depth: %d\\n&#x27;, maxD);
continue;", shape=box];
  201 [label="if(choice == 9)", shape=box];
  202 [label="int nr, nc;
printf(&#x27;New rows cols (10..%d): &#x27;, MAXR-1);", shape=box];
  203 [label="if(scanf(&#x27;%d %d&#x27;,&amp;nr,&amp;nc)!=2)", shape=box];
  204 [label="printf(&#x27;Bad\\n&#x27;);
continue;", shape=box];
  205 [label="if(nr&lt;10||nc&lt;10||nr&gt;MAXR||nc&gt;MAXC)", shape=box];
  206 [label="printf(&#x27;Out of range\\n&#x27;);
continue;
rows=nr;
cols=nc;
startR=1;
startC=1;
endR=rows-2;
endC=cols-2;", shape=box];
  207 [label="for(i=0;i&lt;rows;i++)", shape=box];
  208 [label="for (j=0;
j&lt;cols;
j++)", shape=box];
  209 [label="if(i==0||j==0||i==rows-1||j==cols-1)", shape=box];
  210 [label="maze[i][j]=&#x27;#&#x27;;", shape=box];
  211 [label="else", shape=box];
  212 [label="maze[i][j] = ((rand()%100) &lt; 35) ? &#x27;#&#x27; : &#x27;.&#x27;;
visited[i][j]=0;
parentR[i][j]=-1;
parentC[i][j]=-1;
maze[startR][startC]=&#x27;S&#x27;;
maze[endR][endC]=&#x27;E&#x27;;
printf(&#x27;Resized to %d x %d\\n&#x27;, rows, cols);
continue;
printf(&#x27;Invalid option\\n&#x27;);", shape=box];
  213 [label="return 0;", shape=box];
  214 [label="Exit", shape=box];
  0 -> 1;
  1 -> 2;
  2 -> 3;
  3 -> 4;
  4 -> 5;
  4 -> 6;
  5 -> 6;
  6 -> 7;
  7 -> 8;
  8 -> 9;
  9 -> 10;
  10 -> 11;
  11 -> 12;
  12 -> 12;
  12 -> 13;
  13 -> 14;
  14 -> 15;
  15 -> 16;
  16 -> 17;
  17 -> 18;
  18 -> 19;
  19 -> 20;
  20 -> 21;
  21 -> 22;
  22 -> 23;
  23 -> 23;
  23 -> 21;
  23 -> 24;
  24 -> 25;
  25 -> 26;
  26 -> 27;
  27 -> 28;
  28 -> 29;
  29 -> 30;
  29 -> 33;
  30 -> 31;
  31 -> 32;
  32 -> 33;
  33 -> 34;
  34 -> 35;
  35 -> 36;
  36 -> 37;
  37 -> 38;
  37 -> 39;
  38 -> 39;
  39 -> 40;
  40 -> 41;
  41 -> 42;
  42 -> 43;
  43 -> 44;
  44 -> 45;
  45 -> 46;
  45 -> 55;
  45 -> 61;
  45 -> 67;
  46 -> 47;
  47 -> 48;
  48 -> 49;
  49 -> 50;
  50 -> 51;
  51 -> 52;
  52 -> 53;
  53 -> 54;
  54 -> 55;
  55 -> 56;
  56 -> 57;
  57 -> 58;
  58 -> 59;
  59 -> 60;
  60 -> 61;
  61 -> 62;
  62 -> 63;
  63 -> 64;
  64 -> 65;
  65 -> 66;
  66 -> 67;
  67 -> 68;
  67 -> 70;
  68 -> 68;
  68 -> 69;
  69 -> 70;
  70 -> 71;
  71 -> 72;
  72 -> 73;
  73 -> 74;
  74 -> 74;
  74 -> 75;
  75 -> 76;
  76 -> 77;
  77 -> 78;
  78 -> 79;
  79 -> 80;
  80 -> 81;
  81 -> 76;
  81 -> 82;
  82 -> 83;
  83 -> 84;
  84 -> 85;
  85 -> 86;
  86 -> 87;
  87 -> 88;
  88 -> 89;
  89 -> 90;
  90 -> 91;
  91 -> 92;
  92 -> 93;
  93 -> 94;
  93 -> 98;
  94 -> 95;
  95 -> 96;
  96 -> 95;
  96 -> 97;
  97 -> 98;
  98 -> 99;
  99 -> 100;
  100 -> 101;
  101 -> 102;
  102 -> 102;
  102 -> 103;
  103 -> 104;
  104 -> 105;
  105 -> 106;
  106 -> 107;
  107 -> 108;
  108 -> 109;
  109 -> 104;
  109 -> 110;
  110 -> 111;
  111 -> 112;
  112 -> 113;
  113 -> 114;
  114 -> 115;
  115 -> 116;
  116 -> 117;
  117 -> 118;
  118 -> 119;
  119 -> 120;
  120 -> 121;
  121 -> 122;
  121 -> 126;
  122 -> 123;
  123 -> 124;
  124 -> 123;
  124 -> 125;
  125 -> 126;
  126 -> 127;
  127 -> 128;
  128 -> 129;
  129 -> 129;
  129 -> 130;
  130 -> 131;
  131 -> 132;
  132 -> 133;
  133 -> 134;
  134 -> 135;
  135 -> 136;
  136 -> 137;
  137 -> 138;
  138 -> 139;
  139 -> 140;
  140 -> 135;
  140 -> 141;
  141 -> 142;
  142 -> 143;
  143 -> 144;
  144 -> 145;
  145 -> 146;
  146 -> 147;
  147 -> 148;
  148 -> 149;
  148 -> 156;
  149 -> 150;
  150 -> 151;
  151 -> 150;
  151 -> 152;
  152 -> 153;
  153 -> 154;
  154 -> 155;
  155 -> 156;
  156 -> 157;
  157 -> 158;
  158 -> 159;
  159 -> 160;
  160 -> 161;
  160 -> 165;
  161 -> 162;
  162 -> 163;
  163 -> 162;
  163 -> 164;
  164 -> 165;
  165 -> 166;
  166 -> 167;
  167 -> 168;
  168 -> 169;
  169 -> 170;
  170 -> 171;
  171 -> 172;
  171 -> 173;
  172 -> 173;
  173 -> 174;
  174 -> 175;
  175 -> 176;
  176 -> 177;
  177 -> 177;
  177 -> 175;
  177 -> 178;
  178 -> 179;
  179 -> 180;
  180 -> 181;
  181 -> 182;
  182 -> 183;
  183 -> 184;
  184 -> 185;
  185 -> 186;
  186 -> 187;
  187 -> 188;
  188 -> 189;
  189 -> 190;
  190 -> 191;
  191 -> 189;
  191 -> 187;
  191 -> 192;
  192 -> 193;
  193 -> 194;
  194 -> 195;
  195 -> 196;
  196 -> 197;
  197 -> 198;
  198 -> 199;
  199 -> 200;
  200 -> 201;
  201 -> 202;
  202 -> 203;
  203 -> 204;
  204 -> 205;
  205 -> 206;
  206 -> 207;
  207 -> 208;
  208 -> 209;
  209 -> 210;
  209 -> 211;
  210 -> 211;
  211 -> 207;
  211 -> 212;
  212 -> 213;
  213 -> 214;
}
